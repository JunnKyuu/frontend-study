# Node.js 기초

## 1. 갑자기 Node.js?

- React.js는 Node.js 기반으로 돌아가므로 Node.js의 개념이 필요

<br>

### Node.js

- 웹 브라우저가 아닌 환경에서도 Javascript 코드를 실행시켜주는 자바스크립트의 런타임, 실행 환경
- 즉 Node.js는 Javascript 코드의 구동기
    - 구동기란 게임기가 게임을 실행시켜주듯이 어떤 것을 실행시켜 주는 환경

- **단순한 상호작용만 개발할 수 있었던 언어인 Javascript를 범용적으로 사용할 수 있도록 도와주는 Javascript의 실행 환경, 즉 런타입이며 우리가 배우고자 하는 React 또한 Node.js 기반으로 동작**

<br>

## 2. npm

- Node.js의 프로젝트의 단위인 패키지를 관리하는 도구
- 패키지를 생성, 외부 라이브러리를 설치, 삭제를 도와줌

<br>

### 패키지

- Node.js 환경에서 사용하는 프로그램 단위
- Javascript 앱, React 앱, 라이브러리는 패키지로 이루어짐

<br>

### node.js 환경에서 Javascript 파일 실행

- 원래 브라우저 상에서 Javascript가 실행되었는데, 이것을 Node.js 환경에서 실행하고자 함
- npm init을 통해 node.js 패키지를 생성
- index.js 파일을 생성해서, 콘솔창에 node index.js를 치면 실행
![](https://velog.velcdn.com/images/junnkyuu/post/8cd94840-277e-4ca3-b58d-5b954fe9b0a9/image.png)

- 경로가 복잡해지면 package.json 폴더에서 sciprts를 수정하면 됨
- “start” : “node src/index.js”을 추가하면, npm run start 명령어로 src폴더의 index.js을 실행할 수 있음
![](https://velog.velcdn.com/images/junnkyuu/post/12f1cb96-4fcc-41ad-8bd8-d00d6f1df393/image.png)

---
<br>

## 3. Node.js 모듈 시스템

### 모듈

- 여러 기능들을 한 파일에 작성하면 코드양이 엄청 많아짐
- 버그 수정, 기능 수정이 어렵다
- 효율성, 생산성이 떨어짐
- 기능별로 파일을 나눠서 개발함
- 기능별로 나뉘어진 각각의 Javascript 파일을 모듈이라고 부름

<br>

### 모듈 시스템

- 모듈을 생성하고, 불러오고, 사용하는 등의 모듈을 다루는 다양한 기능을 제공하는 시스템
- Javascript에는 여러 모듈 시스템이 있음
    - Common JS (CJS)
    - ES Module (ESM) 등등

<br>

### Common JS 모듈 시스템 실습

- 내보내고자 하는 모듈에서 module.exports = {}을 사용
- 받고자 하는 모듈에서 require(경로)를 사용
- const moduleData = require(경로)를 하면 객체 형태로 저장되어 꺼내서 사용하거나 구조분해 할당해서 사용가능
![](https://velog.velcdn.com/images/junnkyuu/post/127cd601-dd3e-40c4-93ff-1c3ebaf7d9a8/image.png)

<br>

### ES 모듈 시스템 실습

- ES 모듈 시스템을 사용하려면, package.json 파일에서 “type” : “module”을 추가해줘함. 추가하면 Common JS를 사용하지 못해서 npm run start를 하면 오류가 발생
![](https://velog.velcdn.com/images/junnkyuu/post/d3706d37-c583-4aec-bd87-6236de11f58a/image.png)

- 내보내고자 하는 모듈에서 export = {}안에 원하는 것을 담음
- 받고자 하는 모듈에서 import { } 경로를 사용. ES 모듈 시스템을 사용할 때는 확장자까지 꼭 적어야 함
![](https://velog.velcdn.com/images/junnkyuu/post/10810531-5614-427b-96b9-14e8d247b699/image.png)

- 함수 앞에 export 키워드를 붙여도 똑같이 동작
![](https://velog.velcdn.com/images/junnkyuu/post/c50efbd6-42e9-4ed4-880b-82bd4d8c3fcd/image.png)

- export default를 붙여서 default로 내보낼 수 있음
![](https://velog.velcdn.com/images/junnkyuu/post/61860587-bb1d-48f9-bfa6-5dd39d678268/image.png)

- 동일한 경로에서 불러오는 import 문은 합칠 수 있음
![](https://velog.velcdn.com/images/junnkyuu/post/62c78b42-f3ad-4ded-b6b7-c0e977c145f7/image.png)

<br>

## 4. Node.js 라이브러리 사용

### 라이브러리

- 프로그램을 개발할 때 필요한 다양한 기능들을 미리 만들어 모듈화 해놓은 것
- npmjs.com에서 원하는 node.js 라이브러리를 가져와 import해서 사용할 수 있음
![](https://velog.velcdn.com/images/junnkyuu/post/b739752f-1146-447a-8ee9-1fac0b6bb9db/image.png)

<br>

### Node.js 라이브러리 실습

- npmjs.com에서 원하는 라이브러리를 찾고. npm i를 사용해서 설치
![](https://velog.velcdn.com/images/junnkyuu/post/5351a6ea-6b1f-44e2-a348-b0f9246573bf/image.png)

- 설치하면 package.json 파일에 dependencies에 randomcolor의 버전이 추가되고, node_modules, package-lock.json 파일이 추가됨
    - node_modules는 실제로 우리가 설치한 라이브러리가 저장됨
    - package-lock.json는 package.json보다 더 정확하고 엄밀하게 우리가 사용하는 라이브러리의 정보를 저장
- 설치한 randomcolor 라이브러리를 import로 불러옴
    - 라이브러리를 불러올 때는 경로말고 이름만 명시
- 실행해 보면 아래와 같이 hex값을 랜덤으로 출력
![](https://velog.velcdn.com/images/junnkyuu/post/31e8f4f0-2ad1-463e-82e0-3ba659355df9/image.png)

- package-lock.json, node_modules 파일이 삭제되면, package.json의 dependencies에 있는 정보로 npm i 명령어를 통해 모든 라이브러리를 다시 다운받을 수 있음
- 따라서 node_modules 파일을 굳이 git이나 다른 것을 통해 공유하지 않음

---
<br>

# React.js 개론

## 1. React?
![](https://velog.velcdn.com/images/junnkyuu/post/f7d7ce9d-907a-4f8d-a552-1aa1d9069f42/image.png)

- Meta(Facebook)이 개발한 오픈소스 Javascript 라이브러리
- 대규모 웹 서비스의 UI를 더 편하게 개발하기 위해 만들어진 기술
- 가장 인기있는 프론트엔드에서 사용되는 라이브러리


### React의 특징

#### Component를 기반으로 UI를 표현
![](https://velog.velcdn.com/images/junnkyuu/post/e31d69ca-2de7-40b0-bc44-692799f60511/image.png)

- Component : 화면을 구성하는 요소, UI를 구성하는 요소

- 웹 페이지가 Header, Main, Footer가 있다고 했을 때, React는 이 웹 페이지를 Header.js, Main.js, Footer.js로 만들어서 레고 조립하듯이 3개의 Component를 합쳐서 만들 수 있음

- 기존의 html로 작성하면 개발하는 중에 중복이 많아짐

- React에서는 모든 요소들을 Component를 모듈화해서 사용하기 때문에 한 Component를 여러 페이지에서 불러와 사용하게 함

- 따라서 중복이 줄어들고 유지보수가 쉬움

<br>


#### 화면 업데이트 구현이 쉬움

- 업데이트 : 사용자의 행동(클릭, 드래그)에 따라 웹 페이지가 스스로 모습을 바꿔 상호작용 하는 것
- React는 선언형 프로그래밍이라서 화면 업데이트를 구현하기 쉬움
    - 선언형 프로그래밍 : 과정은 생략하고 목적만 간결히 명시하는 방법. 과정은 상관없고, 원하는 것만 불러옴
    - 명령형 프로그래밍 : 목적을 이루기 위한 모든 일련의 과정을 설명하는 방식
    
- 기존의 Javascript는 명령형 프로그래밍 방식이기 때문에 업데이트를 구현하려면 모든 과정을 하나 하나 다 설명해야 하고, 코드가 길고 복잡해짐

- React는 Component라는 것을 통해 웹 페이지를 개발한다고 했는데, 각각의 Component에는 State라는 것을 통해 상태를 저장함
![](https://velog.velcdn.com/images/junnkyuu/post/17758fad-f958-47dd-a98b-7e51ed876078/image.png)

- 이 State 값이 바뀌면 Component가 바뀐 State값에 따라서 각각 다른 UI를 화면에 렌더링하도록 설정해줌. State변수 값이 1로 바뀌면 1번 UI를 렌더링, 2로 바뀌면 2번 UI로 렌더링하도록 설정할 수 있어서 훨씬 더 편하고 간결하게 업데이트 구현 가능
![](https://velog.velcdn.com/images/junnkyuu/post/0c49d783-07e9-4a69-a32c-8bdf493a2939/image.png)

- **즉, React는 업데이트를 위한 복잡한 동작을 직접 정의할 필요없이, 특정 변수의 값을 바꾸는 것 만으로도 화면을 업데이트 가능**

<br>

#### 화면 업데이트가 빠르게 처리됨

![](https://velog.velcdn.com/images/junnkyuu/post/638b5b16-e0ad-4a68-b863-ad271e7d4590/image.png)

- 브라우저 렌더링 과정(Critical Rendering Path)
    1. HTML -> DOM, CSS -> CSSOM
    2. DOM, CSSOM을 합쳐서 Render Tree를 형성
    3. 요소들의 layout 작업 
    4. 요소를 실제 화면에 그리는 paint
    
![](https://velog.velcdn.com/images/junnkyuu/post/99635d3e-5bbf-45b7-a5d0-baf94064fef3/image.png)

- Javascript가 DOM을 수정하게 되면 업데이트 발생
- 이럴 경우 Critical Render Path를 처음부터 진행
- 즉 DOM, CSSOM을 형성 -> Render Tree를 형성 -> 다시 모든 요소들의 layout 작업(Reflow) -> 다시 모든 요소를 화면에 그리는 paint 작업을 처음부터 진행(Repaint)
- Critical Render Path 중 Layout과 Paint 과정이 제일 오래 걸리는 작업


![](https://velog.velcdn.com/images/junnkyuu/post/8b3f60b0-1a2b-40fd-b104-565d53d85a0b/image.png)
- 업데이트를 한 번에 모았다가 해주는 것이 중요한데, React는 Virtual DOM을 이용해서 진행함

![](https://velog.velcdn.com/images/junnkyuu/post/540ee4f0-d026-42a1-b967-0a083d02610e/image.png)

- Virtual DOM
    - DOM을 Javascript 객체로 흉내낸 것으로 일종의 복제판
    - React는 업데이트가 발생하면 실제 DOM을 수정하기 전에 이 가상의 복제판 DOM에 먼저 반영해 놓음
    
![](https://velog.velcdn.com/images/junnkyuu/post/19be48d0-99da-48c6-9c11-279b3d8c090b/image.png)

- 위처럼 동시에 3개의 업데이트가 발생했다고 했을 때, React는 먼저 Javascript 객체인 virtualDOM에 업데이트를 발생한 순서대로 반영함

![](https://velog.velcdn.com/images/junnkyuu/post/730b41a8-6f4f-43ec-b018-db31bafb1423/image.png)

- 동시에 발생한 업데이트들이 다 모이면 한 번에 반영해서 DOM을 업데이트 함
- 일종의 버퍼역할을 해서 업데이트들을 저장해놓음

<br>

## 2. React App 생성해보기

### React Application?

- React로 만들어진 대다수의 웹 서비스들은 단순한 웹 페이지의 기능을 넘어서 사실상 애플리케이션에 가까운 다양한 기능들을 제공하므로, 웹에서 동작하는 애플리케이션과 같다는 의미
- React App, React Application이라고 말함

<br>

### React App 생성 및 폴더, 파일 구조

![](https://velog.velcdn.com/images/junnkyuu/post/0828325c-976e-4983-aaa8-6615da6829c8/image.png)

- 차세대 프론트엔드 개발 툴인 Vite을 이용해서 기본 설정이 적용된 React App을 생성

![](https://velog.velcdn.com/images/junnkyuu/post/6a139b5e-b6d0-4743-b795-d35f39269326/image.png)

- npm create vite@latest라고 콘솔에 치고 React, Javascript를 선택하면 기본 설정이 되어있는 React 앱이 설치됨

![](https://velog.velcdn.com/images/junnkyuu/post/a7014f63-33ed-49f7-89c6-c397eb148d8d/image.png)

- React도 node.js 환경이기 때문에 package.json 파일이 있음. 아직 라이브러리들이 설치되지 않았기 때문에 npm install / npm i 명령어를 통해 package.json에 있는 라이브러리들을 설치함

![](https://velog.velcdn.com/images/junnkyuu/post/4b6749b9-3ea0-4318-aab0-8bcd44f6f80d/image.png)

- React 앱을 개발하기 위해 필요한 수많은 라이브러리들이 설치가 됨. 이처럼 필요한 라이브러리들을 vite을 통해 쉽게 설치할 수 있음

![](https://velog.velcdn.com/images/junnkyuu/post/832ad301-f8ab-4a07-8522-a5183147f1c8/image.png)

- public 폴더는 이미지 파일을 보관하거나, 폰트, 동영상 같은 코드가 아닌 정적인 파일들을 보관하는 저장소

![](https://velog.velcdn.com/images/junnkyuu/post/b3b90095-0859-4d4a-a7ed-b3d7b7628f23/image.png)

- src 폴더는 소스의 약자로 실제 작성하게 될 React, Javascript 코드들을 보관하는 폴더

![](https://velog.velcdn.com/images/junnkyuu/post/6d009691-fcc7-4c12-8629-3f7ed85eb0bc/image.png)

- assets 폴더 안에 public 폴더와 비슷하게 이미지, 폰트 등의 정적 파일을 보관할 수 있음. 단 조금의 차이는 있음

![](https://velog.velcdn.com/images/junnkyuu/post/a5934b95-3a7c-4900-a3ec-cdce5172cba3/image.png)

- .eslint.cjs 파일은 eslint라는 도구의 설정 파일
- eslint는 개발자들 사이에 코드 스타일을 통일하는 데에 도움을 주는 도구

![](https://velog.velcdn.com/images/junnkyuu/post/4f3c0842-121f-4019-a926-80d87e40daa8/image.png)

- .gitignore 파일은 React 앱을 github 같은 곳에 업로드할 때 올리면 안되는 파일들을 명시하는 곳

![](https://velog.velcdn.com/images/junnkyuu/post/7ae43ef0-84dc-406b-81dc-7e418698afee/image.png)

- index.html 파일은 React 앱의 기본적인 틀 역할을 하는 HTML 코드가 담긴 파일
- React는 Component들을 이 index.html의 DOM을 수정해서 추가하는 방식으로 동작함. 이때 틀이 되는 파일

![](https://velog.velcdn.com/images/junnkyuu/post/8140c8df-c231-47dc-85e5-bb9b206b28bb/image.png)

- vite.config.js 파일은 React 앱을 만들 때 사용한 vite라는 도구의 옵션을 설정하는 파일

<br>

### React App 실행

![](https://velog.velcdn.com/images/junnkyuu/post/908c8999-10e5-420d-8d31-ce715b557aba/image.png)

- package.json의 scripts를 보면 개발용으로 실행할 수 있는 dev 명령어가 있음. 

![](https://velog.velcdn.com/images/junnkyuu/post/8263678a-42f1-4606-bcb5-0b3f05e9af77/image.png)

- npm run dev로 실행하고, localhost 주소로 가면 위 사진처럼 실행이 됨

![](https://velog.velcdn.com/images/junnkyuu/post/e84297bd-7962-4278-aa68-893a7743013e/image.png)

- h + enter를 누르면 단축키를 알려줌
- 각각 새로고침, url을 보여줌, 브라우저에서 열기, 콘솔 지우기, 앱 종료가 있음

<br>

## 3. React App 구동 원리

![](https://velog.velcdn.com/images/junnkyuu/post/05f61238-5d85-4674-b506-869661bb4982/image.png)

- vite를 통해 생성한 React 앱에는 웹 서버가 내장되어 있음
- npm run dev라는 명령어는 React 앱 서버를 가동시켜라라는 명령어

![](https://velog.velcdn.com/images/junnkyuu/post/e729c73a-52f2-4801-a9ad-72717b8682f9/image.png)

- 위 메세지는 React 앱 서버가 돌아가고 있다는 뜻
- localhost:5173은 우리가 접속할 수 있는 내 컴퓨터의 React 앱 서버 주소

![](https://velog.velcdn.com/images/junnkyuu/post/142f4251-3c0f-4a1a-8d9c-b68287c330fd/image.png)

![](https://velog.velcdn.com/images/junnkyuu/post/82ea6c2e-68cb-4c71-aa13-e5efd1466eb9/image.png)

- 위와 같이 접속 가능
- React 앱을 실행하면 먼저 index.html 파일은 브라우저에게 보내줌
- index.html의 body 태그를 보면 비어있는데, script 태그의 main.jsx을 동적으로 추가함

![](https://velog.velcdn.com/images/junnkyuu/post/3acb0fd2-4210-4c78-ad21-2c8eeadd7eb2/image.png)

- main.jsx는 index.html의 id가 root인 것을 React의 root로 변환해주고 있음
- render라는 메서드를 호출해서 위에서 만든 root 아래에 App Component를 렌더링

![](https://velog.velcdn.com/images/junnkyuu/post/8ca1c450-4f44-450e-8e79-e6254cc28c43/image.png)

- App.jsx는 html 태그들을 return하고 있음
- 즉, App.jsx가 return하는 태그들을 main.jsx에서 render하고 그것을 index.html에 동적으로 추가해서 화면을 보여주는 것

![](https://velog.velcdn.com/images/junnkyuu/post/33342697-ef1d-4b02-ba93-4255724c1989/image.png)

- 개발자 도구를 열어서 보면, id가 root인 div태그 아래에 렌더링되는 것을 볼 수 있음

---
<br>

# React.js 입문

## 1. React Component

- Javascript 함수가 html 태그들을 반환하도록 설정할 수 있음
- 이렇게 html 태그들을 반환하는 함수를 Component
- Class를 통해서 Component를 만들 수 있지만, 코드의 양이 많아지므로 사용하지 않음
- 함수형 Component의 첫글자는 대문자

![](https://velog.velcdn.com/images/junnkyuu/post/18467305-22b2-4649-880b-252bc2fba946/image.png)

- Header라는 함수형 Component를 생성
- 원하는 위치에 Component를 배치하면 렌더링이 돼서 화면에 출력 
- 여기서 부모 Component는 App, 자식 Component는 Header

![](https://velog.velcdn.com/images/junnkyuu/post/0efe8e8c-b6ff-4118-a095-5f6d943f1277/image.png)

![](https://velog.velcdn.com/images/junnkyuu/post/5790a9c7-8636-4030-a97f-8430ebf1a9f6/image.png)

- Component들을 한 파일에 작성하는 것보다 기능별로 모듈로 나눠서 작성하는 게 더 좋음
- components 폴더를 만들고 이 안에 App.jsx를 제외한 component들을 넣어줌
- components 폴더 안에 Header.jsx 파일을 작성
- ES 모듈 시스템으로 Header.jsx에서는 export default, App.jsx에서는 import Header from './components/Header.jsx'를 사용함

![](https://velog.velcdn.com/images/junnkyuu/post/9e54c0d5-cc5c-43de-99f0-65a69e546bed/image.png)

- Main.jsx, Footer.jsx도 추가해서 렌더링한 결과

<br>

## 2. JSX로 UI 표현하기

### JSX

![](https://velog.velcdn.com/images/junnkyuu/post/e9b69f2b-2f8e-45a6-92c4-f02399598343/image.png)

- Javascript Extension으로 Javascript의 확장된 문법
- Javascript와 html을 혼용해서 사용 가능

![](https://velog.velcdn.com/images/junnkyuu/post/19261e90-36d8-40ef-9b6e-3943eee8f1cc/image.png)

- 특정 변수의 값을 html로 렌더링 가능

<br>

### JSX 사용시 주의사항
- {}안에는 Javascript 표현식만 가능
- 숫자, 문자열, 배열의 값만 렌더링 가능
- 모든 태그는 닫혀있어야 함
- 최상위 태그는 반드시 하나    
    
![](https://velog.velcdn.com/images/junnkyuu/post/e0bcd1a2-c98e-4dde-bcc0-0c9088ab0443/image.png)

- 이런 식으로 삼항연산자도 가능

<br>

### JSX로 스타일 구현

![](https://velog.velcdn.com/images/junnkyuu/post/1a0d930c-3156-4574-8d5b-76488bbf9580/image.png)

- 요소에 직접 스타일 속성 지정
    - 객체 형태로 전달
    - 속성명은 CSS 스타일과 다르게 -쓰지 않고 camelCase로 작성
    - 속성값은 문자열로 전달
    - 가독성이 떨어질 수 있음

![](https://velog.velcdn.com/images/junnkyuu/post/ad923aa5-d08a-4ce5-8872-6b3b3f5bd3e4/image.png)

- CSS 파일을 만들어서 스타일 속성 지정
    - class가 아니라 className

<br>

## 3. State, Props

#### State
- 계속해서 변화하는 특정 상태에 따라 다른 동작을 함

```
import React, { useState } from "react";

const Counter = () => {

  const [count, setCount] = useState(0);

  const onIncrease = () => {
    setCount(count + 1);
  };

  const onDecrease = () => {
    setCount(count - 1);
  };

  return (
    <div>
      <h2>{count}</h2>
      <button onClick={onIncrease}>+</button>
      <button onClick={onDecrease}>-</button>
    </div>
  );
};

export default Counter;
```

#### Props
- 객체의 프로퍼티스의 줄임말
- Component에게 데이터를 전달하는 기본적이고 효율적인 기능

```
import React, { useState } from "react";

const Counter = (props) => {

  const [count, setCount] = useState(props.initialValue);

  const onIncrease = () => {
    setCount(count + 1);
  };

  const onDecrease = () => {
    setCount(count - 1);
  };

  return (
    <div>
      <h2>{count}</h2>
      <button onClick={onIncrease}>+</button>
      <button onClick={onDecrease}>-</button>
    </div>
  );
};

export default Counter;
```

<br>

### 4. useRef, React Hooks

#### useRef
- .current 프로퍼티로 전달된 인자로 초기화된 변경 가능한 ref 객체 반환
- 반환된 객체는 lifecycle을 통해 유지
    - Component가 계속 렌더링 되어도, 언마운트되기 전까지 값 유지 가능
    - current 속성은 값을 변경해도 상태를 변경할 때처럼 렌더링이 다시 되지 않음 --> 성능 향상
- 생성

```
const 이름 = useRef(초기값)
```

- 반환 요소에 접근

```
<input ref = {이름} />
```

- 어떤 값을 저장하는 공간으로 사용
- DOM 요소에 접근할 때 사용

<br>

#### React Hooks

- Class Component의 기능을 함수형 Component에서도 사용할 수 있도록 도와주는 메서드
- useState, useRef, useEffect, useReducer ,,,,
- custom hook 제작 가능

---
<br>

[사진 및 참고 출처 - 한입 크기로 잘라먹는 리액트](https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%EB%A6%AC%EC%95%A1%ED%8A%B8)
