# 한입 React 1주차 내용 정리본

## Node.js

- JavaScript 실행 환경 (Run Time)
- 실행 환경 = 구동기
- Node.js 만든 이유 : JS는 매우 유연하게 설계 되어 생산성이 매우 높았는데 사용자들이 웹 브라우저 밖에서도 쓰고, 자바스크립트로 웹 서버도 만들고 싶다는 요구에 따라 → 웹 전성기 이끔

## Node.js 설치하기

- 설치 확인 명령어 : node -v, npm -v

## Node.js 사용하기

- 패키지 : Node.js에서 사용하는 프로그램의 단위
- npm init 으로 패키지 생성
- node 실행 명령어 : node <실행시킬 파일경로와 이름>
- package.json 파일 안의 “scripts”에 ‘“start” : <실행시킬 파일 경로와 이름>’명령어 추가 후 터미널에 npm run start 입력하면 npm 실행

## Node.js 모듈 시스템 이해하기

- 모듈 시스템 : 모듈을 생성하고, 불러오고, 사용하는 등의 모듈을 다루는 다양한 기능을 제공하는 시스템
- 모듈(Module) : 기능별로 나누어진 각각의 js 파일들
- 여러가지 모듈 시스템 : Common JS (CJS), ES Module (ESM), AMD, UMD 등등
- ESM 모듈 시스템 사용하려면 package.json 파일 안의 “scripts”에 ‘“type” : “module”’ 명령어 추가해야 함
- CJS와 ESM 동시 사용 불가
- ESM : 모듈로부터 어떠한 값을 내보낼 때 ‘export {};’ 처럼 export 뒤에 객체를 리터럴로 생성하여 값들을 담아주면 됨, 모듈로부터 어떠한 값을 가져올 때 ‘import {} from <모듈 경로와 이름>;’
- ESM 사용시 함수 앞에 바로 export 붙여도 됨
- export default로 내보내면 그 함수는 모듈을 대표하는 단 하나의 값이 됨, import 할 땐 함수 이름만 불러옴
- import 할 때 한번에 많은 함수 이름 작성 가능

## Node.js 라이브러리 사용하기

- 라이브러리 : 프로그램을 개발할 때 필요한 다양한 기능들을 미리 만들어 모듈화 해 놓은 것
- npmjs : Node.js 라이브러리계의 백화점
- 라이브러리 설치하면 package.json 내 “dependencies”에 설치한 대략적인 라이브러리 버전 등 명시
- node_modules: 라이브러리 실제 설치된 곳, package-lock.json : 정확한 버전 명시

## React.js

- React.js : Meta(Facebook)이 개발한 오픈소스 JavaScript 라이브러리
- 대규모 웹 서비스의 UI를 더 편하게 개발하기 위해 만들어진 기술
- 넷플, 페이스북, 인스타그램, 노션 등이 react.js로 만들어짐

> 리액트의 기술적 특징
> 
> 1. 컴포넌트를 기반으로 UI를 표현
> 2. 화면 업데이트 구현 용이 (선언형 프로그래밍 - 목적만 깔끔하게 명시, 코드 간결)
>     
>     [사진ㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇ]
>     
> 3. 화면 업데이트가 빠르게 처리됨
>     
>     ![11.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20React%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20e27608776e66463b96ae6dc7b6190a21/11.jpeg)
>     
>     ![12.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20React%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20e27608776e66463b96ae6dc7b6190a21/12.jpeg)
>     
>     ![13.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20React%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20e27608776e66463b96ae6dc7b6190a21/13.jpeg)
>     
>     > Virtual Dom
>     > 
>     > - DOM을 자바스크립트 객체로 흉내낸 것으로 일종의 복제판
>     > - React는 업데이트가 발생하면 실제 DOM을 수정하기 전에 이 기상의 복제판 DOM에 먼저 반영해봄 → 연습 스윙 같은 느낌
>     > 
>     > ![vd.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20React%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20e27608776e66463b96ae6dc7b6190a21/vd.jpeg)
>     > 

## React App 생성하기

- VITE 생성 명령어 : npm create vite@latest
- Public 폴더 : 이미지, 폰트, 동영상 파일 등과 같은 코드가 아닌 정적인 파일들을 보관하는 저장소
- src 폴더 : source 약자로 실제 우리가 작성하게 될 리액트나 자바스크립트 코드들을 보관하는 저장소
- .eslintrc.cjs : eslint(개발자들의 코드 스타일 통일해주는 역할)라는 도구의 설정 파일
- index.html : DOM을 수정해서 추가할 때 가장 기본적인 틀이 되는 파일
- 리액트 실행 명령어 : npm run dev

## React App 구동 원리

- [localhost](http://localhost) : 우리가 쓰는 컴퓨터 주소
    
    ![lo.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20React%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20e27608776e66463b96ae6dc7b6190a21/lo.jpeg)
    
    → 하나의 pc에서여러 개의 서버가 동작하고 있을 때 주소로만 요청을 받게 되면 어떠한 서버가 응답해야 하는지 모호하기 때문에 이러한 상황을 막기 위해 고유한 포트 번호 필요로함
    

```jsx
// main.jsx
ReactDOM.createRoot(document.getElementById('root')).render (
	<React.StrictMode>
		<App />
	</React.StrictMode>,
)
```

- createRoot 메서드 : 인수로 전달받은 HTML 요소를 리액트의 루트로 만들어주는 역할
- render 메서드 호출 → 여기에서는 <App /> 컴포넌트 렌더링

> 정리 : 리액트 앱은 index.html에서 main.jsx라는 자바스크립트 파일을 실행 → 이 자바스크립트 파일에서는 app.jsx 파일에 저장되어 있는 앱 함수가 리턴하는 요소를 화면에 렌더링
> 

## React 컴포넌트

- 컴포넌트를 생성하는 함수의 이름은 반드시 첫 글자가 대문자
- 자식 컴포넌트 (다른 컴포넌트의 리턴문 내부에 포함되는 컴포넌트), 부모 컴포넌트 (ex. 앱 컴포넌트)
- 리액트의 모든 컴포넌트들은 화면에 렌더링 되기 위해서는 앱 컴포넌트의 자식 컴포넌트로서 존재해야 함
- src 폴더 내 components 폴더 만들어 이 안에서 파일들을 생성해 모듈화 해 줌

## JSX - UI 표현하기

- JSX (JavaScript Extensions) : 확장된 자바스크립트의 문법
    
    ![jsx.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20React%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20e27608776e66463b96ae6dc7b6190a21/jsx.jpeg)
    

> JSX 주의 사항
> 
> 1. 중괄호 내부에는 자바스크립트 표현식만 넣기 가능 → if, for 문 x
> 2. 숫자, 문자열, 배열 값만 렌더링 됨 → boolean,  undefined, null 값은 렌더링 x
> 3. 모든 태그는 닫혀있어야 함
> 4. 최상위 태그는 반드시 하나여야 함

## Props - 컴포넌트에 값 전달하기

- props : 리액트에서 부모 컴포넌트가 자식 컴포넌트들에게 마치 함수의 인수를 전달하듯 원하는 값을 전달해주는데, 이 때의 컴포넌트에 전달된 값들
- 부모 컴포넌트에서 자식 컴포넌트에게 값을 전달하는 것만 가능 → 자식 컴포넌트에서 부모 컴포넌트로 값을 전달하는 것은 불가능

## Event Handling

- Event : 웹 내부에서 발생하는 사용자의 행동 (ex. 버튼 클릭, 메세지 입력, 스크롤 등등)
- Event Handling : 웹에서 이벤트가 발생했을 때 그것을 처리하는 것 (ex. 사용자가 어떠한 버튼을 클릭하면 경고창 노출, 콘솔의 메세지 출력 등)
- 콜백 함수를 작성하듯이 함수의 이름만 이벤트 핸들러로 설정해주어야 함
- 합성 이벤트 (Synthetic Event) : 모든 웹 브라우저의 이벤트 객체를 하나로 통일한 형태
- 합성 이벤트는 Cross Browsing issue (브라우저 별 스펙이 달라 발생하는 문제)를 편리하게 해결해 줌

## State

- state (상태) : 변화할 수 있는 동적인 값 (컴포넌트의 현재 상태를 보관하는 변수)
- State 값에 따라 렌더링 되는 UI가 결정됨
- 리 렌더(Re-Render), 리 렌더링(Re-Rendering) : 컴포넌트가 다시 렌더링 되는 것
- 하나의 컴포넌트에 여러 개 state 만들기 가능
- useState : useState는 두 개의 요소를 인자로 받는데 첫 번째 요소는 현재 값, 두 번째 요소는 이 state를 변경시키는 상태 변화 함수
    
    ```jsx
    function App() {
    	const [state, setState] = useState(0);
    	// 구조분해 할당 하는 것이 일반적
    	// 여기에서 초기값 : 0
    	
    	return (
    		<>
    			<h1>{state}</h1>
    			<button
    				onClick={() => {
    					setState(state + 1);
    				}}
    			>
    				+
    			</button>
    		</>
    	);
    }
    ```
    
    → 컴포넌트의 state 값이 바뀌면 컴포넌트가 리렌더링되고 그 때 변경된 state 값도 화면에 반영됨
    

## State를 Props로 전달하기

> 리액트 컴포넌트가 리렌더링 되는 상황
> 
> 1. 자신이 관리하는 statea 값이 변경되었을 때
> 2. 자신이 제공 받는 props 값이 변경되었을 때 
> 3. 부모 컴포넌트가 리렌더링 되면 자식 컴포넌트도 리렌더링 됨

## State로 사용자 입력 관리하기

```jsx
const [input, setInput] = useState({
	name: "",
	birth: "",
	country: "",
	bio: "",
});
```

→ 여러 개의 비슷하게 동작하는 이벤트 핸들러들을 하나의 통합된 이벤트 핸들러들로 합쳐 사용 가능, 여러 개의 비슷한 state 값이 있다면 하나의 객체 값으로 묶어 하나의 state로 통합해 관리하면 용이

## useRef - 컴포넌트의 변수 생성하기

- useRef : 새로운 Reference 객체를 생성하는 기능

```jsx
const refObject = useRef()
```

→ refObject : 컴포넌트 내부의 변수로써 일반적인 값들 저장 가능

→ 컴포넌트를 리렌더링 하지 않음

→ 컴포넌트 내부에서 렌더링에 영향을 미치지 않아야 하는 객체를 생성할 때 사용

- useRef와 useState 차이
    
    ![차이.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20React%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20e27608776e66463b96ae6dc7b6190a21/%25E1%2584%258E%25E1%2585%25A1%25E1%2584%258B%25E1%2585%25B5.jpeg)
    

## React Hooks

- 정의 : 클래스 컴포넌트의 기능을 함수 컴포넌트에서도 이용할 수 있도록 도와주는 메서드
    
    ![헤.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20React%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20e27608776e66463b96ae6dc7b6190a21/%25E1%2584%2592%25E1%2585%25A6.jpeg)
    
    ![헤헤.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20React%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20e27608776e66463b96ae6dc7b6190a21/%25E1%2584%2592%25E1%2585%25A6%25E1%2584%2592%25E1%2585%25A6.jpeg)
    

> React Hooks 특징
> 
> 1. 이름 앞에 use라는 접두사가 붙음
> 2. 각각의 메서드들은 영어의 단수형으로 hook이라고 부름
> 3. ex) useState, useRef, useEffect, useReducer 등등
> 4. 함수 컴포넌트 내부에서만 호출되어야 함
> 5. 조건문이나 반복문에서 호출 불가능
> 6. use라는 접두사를 이용해 나만의 새로운 훅인 커스텀 훅 만들기 가능
>     
>     ```jsx
>     // 나만의 Hook도 제작 가능 (Custom Hook)
>     function useInput() {
>     	// input 값 관리하는 Custom Hook
>     	// ...
>     }
>     ```
>