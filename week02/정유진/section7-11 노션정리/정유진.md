# 한입 리액트 section 7-11

## 라이프사이클(LifeCycle)

1. Mount
    - 컴포넌트가 탄생하는 순간
    - 화면에 처음 렌더링 되는 순간
    - “A 컴포넌트가 Mount 되었다!” → A 컴포넌트가 화면에 처음으로 렌더링 되었다
2. Update
    - 컴포넌트가 다시 렌더링 되는 순간
    - 리렌더링 될 때를 의미
    - “A 컴포넌트가 업데이트 되었다!” → A 컴포넌트가 리렌더링 되었다
3. UnMount
    - 컴포넌트가 화면에서 사라지는 순간
    - 렌더링에서 제외 되는 순간을 의미
    - “A 컴포넌트가 언마운트 되었다!” → A 컴포넌트가 화면에서 사라졌다

> 라이프사이클 제어
> 

![1번.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20section%207-11%20d227a56c6cce4423b42fb7d25bbd388a/1%25E1%2584%2587%25E1%2585%25A5%25E1%2586%25AB.jpeg)

→ useEffect 사용하면 쉽게 구현 가능

## useEffect

- 리액트 컴포넌트의 사이드 이펙트를 제어하는 새로운 React Hook

> React 컴포넌트의 사이드 이펙트 : 리액트에서는 “부수적인 효과”, “파생되는 효과” 정도로 해석 가능 → 컴포넌트의 동작에 따라 파생되는 여러 효과
> 

![2번.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20section%207-11%20d227a56c6cce4423b42fb7d25bbd388a/2%25E1%2584%2587%25E1%2585%25A5%25E1%2586%25AB.jpeg)

## useReducer

- 컴포넌트 내부에 새로운 State를 생성하는 React Hook
- 모든 useState는 useReducer로 대체 가능

> useState와 useReducer의 차이점 : useReducer를 이용하면 useState와는 달리 상태를 관리하는 코드들을 컴포넌트 외부로 분리 가능
> 

![3번.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20section%207-11%20d227a56c6cce4423b42fb7d25bbd388a/3%25E1%2584%2587%25E1%2585%25A5%25E1%2586%25AB.jpeg)

![4번.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20section%207-11%20d227a56c6cce4423b42fb7d25bbd388a/4%25E1%2584%2587%25E1%2585%25A5%25E1%2586%25AB.jpeg)

## 최적화(Optimization)

- 웹 서비스의 성능을 개선하는 모든 행위
- 아주 단순한 것부터 아주 어려운 방법까지 매우 다양
- 일반적인 웹 서비스 최적화 방법
    1. 서버의 응답속도 개선
    2. 이미지, 폰트, 코드 파일 등의 정적 파일 로딩 개선
    3. 불필요한 네트워크 요청 줄임
- React App 내부의 최적화 방법
    1. 컴포넌트 내부의 불필요한 연산 방지
    2. 컴포넌트 내부의 불필요한 함수 재생성 방지
    3. 컴포넌트의 불필요한 리렌더링 방지

## useMemo

- “메모이제이션”기법을 기반으로 불필요한 연산을 최적화하는 리액트 훅
- 자매품 : useCallback

> Memoization : 기억해두기, 메모해두기 라는 뜻
> 

![넵.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20section%207-11%20d227a56c6cce4423b42fb7d25bbd388a/%25E1%2584%2582%25E1%2585%25A6%25E1%2586%25B8.jpeg)

→ 최초에 한 번 연산을 수행해서 결과 값을 저장해놓기 때문에 매번 똑같은 연산을 불필요하게 다시 수행할 필요 X

## React.memo

- 컴포넌트를 인수로 받아, 최적화된 컴포넌트로 만들어 변환

```jsx
const MemoizedComponent = memo(Component)
```

→ 인수 : 컴포넌트, 반환값 : 최적화된 컴포넌트

→ 최적화 기능이 추가된 컴포넌트는 props를 기준으로 메모이제이션

![5번.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20section%207-11%20d227a56c6cce4423b42fb7d25bbd388a/5%25E1%2584%2587%25E1%2585%25A5%25E1%2586%25AB.jpeg)

→ MemoizedComponent는 부모 컴포넌트가 리렌더링 되더라도 자신이 받는 props가 바뀌지 않으면 다시는 리렌더링이 발생하지 않도록 메모이제이션 되기 때문에 불필요한 리렌더링이 방지되어 자동으로 최적화 이루어짐

## React Context

- 컴포넌트 간의 데이터를 전달하는 또 다른 방법
- 기존의 props가 가지고 있던 단점 해결 가능 ⇒ Props Drilling 해결

> props의 단점
> 

![6번.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20section%207-11%20d227a56c6cce4423b42fb7d25bbd388a/6%25E1%2584%2587%25E1%2585%25A5%25E1%2586%25AB.jpeg)

> React Context 사용구조
> 

![7번.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20section%207-11%20d227a56c6cce4423b42fb7d25bbd388a/7%25E1%2584%2587%25E1%2585%25A5%25E1%2586%25AB.jpeg)

![8번.jpeg](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20section%207-11%20d227a56c6cce4423b42fb7d25bbd388a/8%25E1%2584%2587%25E1%2585%25A5%25E1%2586%25AB.jpeg)